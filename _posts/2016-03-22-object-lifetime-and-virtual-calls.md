---
layout: post
title: Object lifetime and virtual calls
category: c++ fundamentals
tags: ["c++", "fundamentals", "black magic"]
---

This article is an in-depth answer to "What happens, if I call a virtual method inside constructor?".

It explains, when a call to a method declared as virtual is actually virtual, defines what is object's lifetime, points where constructors and destructors fit into the object lifetime, how compiler and run time keep track of virtual methods available to object at any given moment of its existence and what are the consequences of all those things interacting.

## What is a virtual call?

Virtual call is a method call context in which the address of the code of method is not known at compile time and must be retrieved in run time. Consider this example:

```cpp
struct A {
    virtual void f();
};

A a1 = ...;
A& a2 = ...;
A* a3 = ...;

a1.f();     // (1)
a2.f();     // (2)
a3->f();    // (3)
a3->A::f(); // (4)
```

We have a full knowledge about the `a1` variable at compile time. It's type cannot be anything other, than `struct A`. Therefore, in line marked with (1) the context of call to `A::f()` is static and there is a simple method call, just like any other function or non-virtual method, with the behavior equivalent to the pseudo code of

```cpp
A::f(&a1);
```

We do not have that knowledge in lines (2) and (3). The `a2` variable's type is a reference to `struct A`, which means it can be initialized with an lvalue of any type derived from `A`. Same for `a3` - being a pointer to `struct A` it can also be initialized with a pointer to an value of any type derived from `A`. The pseudo-code for the lines in question must contain some way to get the address from the object:

```cpp
[get_address_from: &a of_method: A::f(void) ](&a2);
[get_address_from: a3 of_method: A::f(void) ](a3);
```

With line (4), however, the author made a conscious decision to resign from virtual call context and chose to use static call to a function known at compile time. Once again we would have a "simple" call to a non-method.

To sum it up:

> Virtual call is context of calling virtual methods on reference or a pointer.

This, however, poses some problems when considering stages of object's duration. The way C++ is designed, the only place virtual call context is possible, is during **object's lifetime**.

## What is object lifetime, and how does it differ from the duration of it's storage?

The storage duration is the time between object allocation and de-allocation. Depending on type of duration those events might be automatic or manual.

_SIDENOTE_: Only _dynamic_ storage duration has manual allocation and de-allocation. Others are attached to: block (in case of _automatic_ storage duration) or expression (again, _automatic_ duration for temporaries), thread (for _thread_ duration, only possible with `thread_local`) or program (for _static_ duration, used for namespace variables) and are managed by the compiler.

**Object lifetime** is defined as either equal to storage duration of the same variable, or contained within this duration. It starts, when the object is fully initialized and ends just before the object is deinitialized.

For example, let's consider a local variable. It is allocated on stack by the code generated by the compiler, the object is then initialized and the lifetime of the object starts. When the closing brace is encountered, the lifetime ends, the object is deinitialized and dealocated, ending the duration of it's storage.

For the trivial types (such as integers and pointers) the initialization is also trivial and sometimes can be omitted. For types with constructors, the initialization is performed by calling the constructor and deinitialization - by calling a destructor. Object is initialized after at least one constructor finishes and before the last destructor is called, but is only fully-initialized if all constructors finish and before the first destructor is called. This is crucial, because the consequence for constructors and destructors is that they are not part of the object lifetime.

> Since object lifetime by definition starts after constructor finishes and before destructor starts, constructors and destructors are not part of object lifetime.

## Why virtual calls are only possible during the lifetime?

This is fully connected to the way C++ treats initialization of the parts of the objects representing ancestors of it's type. When the code drills down through the calls to the constructors of super classes, the language design must answer the question - is the object there, or it is not?

Unlike other languages, which do not have to worry about memory layouts, C++ decided it cannot assume anything about the top-level type of the object in such situations. It declared that objects at any given level **are only partially intialized** and the only parts we may presume to be initialized are our own super-classes and members with their own initializers. In particular, sub-classes are **not** initialized. They will be, but aren't yet.

Which means calling a virtual method in constructor (or destructor) makes no sense. If there are any sub-classes, they are not yet initialized and the method would operate on not yet initialized object. If you are the final class in this hierarchy the virtual call would call your version anyway. ~~So, the result would be as if static call was made.~~ Except it's not.

When calling something within a method, a symbol is looked up among all things accessible from `this` - including it's methods. And any symbol found this way is treated as if prefixed with `this->`. Which means method are called on a pointer. Which means we have a virtual call context.

> Objects inside their super class constructors are only partially initialized.
> 
> Calling a method from within another method (including constructors and destructors) is always done in virtual call context.

## Which virtual method is called?

The one in the `vtbl`, duh.

The virtual method table, or `vtbl`, is generated for a type with at least one virtual method and a pointer to the `vtbl` is always placed in memory layout for this type. It does not have any name, cannot be accessed by the program in any way (except through virtual call), is at least long enough to contain pointers to functions representing all the virtual methods this type knows about.

So, when a virtual method is looked up by the code, it is replaced by an identifier generated by the compiler, the identifier is treated as an offset into the`vtbl` and the pointer to a function is retrieved from the table. Assuming `T::d()` is a fourth virtual method the compiler saw for type `T`, the code

```cpp
T& obj = ...;
obj.d();
```

might result in this code on Intel processors:

```nasm
MOV   ECX,dword ptr [obj]     ; ECX contains this    
MOV   EDX,dword ptr [ECX]     ; EDX contains vtbl  
MOV   EAX,dword ptr [EDX+0Ch] ; move to 4th entry in vtbl
CALL  EAX                     ; method calls with this in ECX 
```

or this code on ARMs:

```nasm
ldr  r3, [obj]   ; r3 contains this
ldr  r3, [r3]    ; ... now pointer to vtbl
add  r3, r3, #12 ; ... to it's 4th entry
ldr  r3, [r3]    ; ... to the function in this entry
ldr  r0, [obj]   ; r0 contains this for method call
blx  r3          ; method call
```

> Virtual methods are gathered in a table containing list of addresses to all those methods for a given type. Address to this table is attached to every object of said type.

## Which virtual table?

And here's where things get interesting. Or scary. Remember C++ decided the objects in constructors are only partially initialized? That the assumption is, the memory for the sub-class is not yet touched and will be initialized later?

Looking up a virtual method inside a constructor means the `vtbl` the object sees is always exactly the same `vtbl` it would get, if it was an object of final class. When the control flow leaves a constructor and move into upper-level constructor, the `vtbl` pointer is updated to reflect the type change. So, even though calling a method inside constructor is made in virtual call context, the negotiated method is, at most, the one defined in current super-class. It will never choose a method from sub-class, because it's not in `vtbl`. It's not in `vtbl`, because the sub-class is not yet initialized.

This applies not only to the concrete objects, but to abstract ones as well. Consider this example:

```cpp
struct A {
    virtual void f() = 0;
};

struct B : A {
    B() { f(); } // (1)
};

struct C : B {
    void f() {};
};

C c;
```

The type `struct C` is not abstract, all methods are provided, so the object may be allocated and used. _However_, line marked with (1) contains a small bomb: inside this constructor the `vtbl` consist of one entry, created for type B, not C. This means the only entry this `vtbl` consists of, is some pure handler equivalent of `abort()` (`__purecall()` in MSVC, `__cxa_pure_virtual()` in GCC).

> Inside any given constructor `vtbl` contains only entries seen so far. The `vtbl` pointers are updated as the code moves up the constructor chain.

## What about destructors?

The `vtbl` dance the code performs inside various constructors happens inside destructors as well, only in reverse order. And destructors also operate in virtual call context. So, calling anything remotely virtual-_ish_ has the same consequences, as in constructors.

> Destructor `vtbl` behavior mirrors constructor behavior.

## Summary

If you are thinking about calling a virtual function from constructor or destructor, don't. Virtual calls have sense only if an object is fully-initialized and _by definition_ objects inside constructors and destructors are not fully-initialized.
